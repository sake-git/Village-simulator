import { Injectable } from '@angular/core';
import { Improvement, RequirementMap } from '../model/improvement';

import { Resource } from '../model/Resource';

@Injectable({
  providedIn: 'root',
})
export class VillageService {
  improvementsDB: Improvement[] = new Array<Improvement>(36);
  maxUsedIndex: number = -1;

  resourceDB: Resource[] = [];

  resourceRequirementMap: RequirementMap[] = [];
  // benefitMap: Map<string, Resource> = new Map();

  constructor() {
    //Initialize the data sets
    this.initializeDataSet();
  }

  //Add improvement,add resources generated and deduct resources used from data sets
  addImprovement(improvement: Improvement): boolean {
    let isValid = this.isResourceAvailable(improvement.type); //Check if required number of resources are available
    if (isValid) {
      //improvement.index = ++this.maxUsedIndex; //index to track improvements primary key
      this.improvementsDB[improvement.index] = improvement; //Add improvement
      let quantities = this.getRequiredMapDB(improvement.type);
      this.addResources([quantities!.benefit]); // Add resources generated by improvement
      this.deductResources(quantities!.required); //Deduct resources required for upgrade
      return true;
    }
    return false;
  }

  //Upgrade improvement, add resources generated and deduct resources used from data sets
  upgradeImprovement(id: number): boolean {
    let index = this.improvementsDB.findIndex((x) => x?.index == id); //get the improvement index by id to upgrade
    if (index > -1) {
      let isValid = this.isResourceAvailable(this.improvementsDB[index].type); //Check if required number of resources are available
      if (isValid) {
        let improvement = this.improvementsDB[index];
        let quantities = this.getRequiredMapDB(improvement.type);
        improvement.level++; //Upgrade improvement
        this.addResources([quantities!.benefit]); // Add resources generated by improvement
        this.deductResources(quantities!.required); //Deduct resources required for upgrade
        return true;
      }
    }
    return false;
  }

  //Downgrade improvement, add resources freed and deduct benefit generated
  downgradeImprovement(id: number): string {
    let index = this.improvementsDB.findIndex((x) => x?.index == id); //Get index of improvement to downgrade
    if (index > -1) {
      let improvement = this.improvementsDB[index]; // Get the improvement record

      let quantities = this.getRequiredMapDB(improvement.type); // get benefit generated by the impovement
      if (!quantities) {
        console.log('Requirements not defined');
        return 'Requirements Map not defined';
      }

      let temp = this.resourceDB.find(
        (x) => x?.type == quantities.benefit.type
      ); // get the count of benefit resource available

      //If the benefit generated by upgrade can be deducted from the current resource pool, then downgrade else stop
      if (
        improvement.level > 0 &&
        temp &&
        temp?.count >= quantities.benefit.count
      ) {
        improvement.level--;
        //Resource pool is sufficient to deduct the credited benefit.
        this.addResources(quantities.required); //Add freed up resources
        this.deductResources([quantities.benefit]); // Deduct the benefits given
        return '';
      } else {
        return 'Not enough resources available to downgrade';
      }
    } else {
      console.error('Improvement not found');
      return 'Improvement Downgrade unsuccessful';
    }
  }

  //Remove improvement, add resources freed and deduct benefit generated
  removeImprovement(id: number): string {
    let index = this.improvementsDB.findIndex((x) => x?.index == id); //Get index of improvement to downgrade
    if (index > -1) {
      let improvement = this.improvementsDB[index];
      console.log(improvement);
      let requirement = this.getRequiredMapDB(improvement.type);
      if (!requirement) {
        console.log('Requirements not defined');
        return 'Requirements Map not defined';
      }
      let quantities = requirement.required; // get the resources consumed for the upgrade
      let benefit = requirement.benefit; // get benefit generated by the impovement

      let benefitCount = benefit.count * improvement.level;
      console.log('Benefit count: ', benefit.count);

      let temp = this.resourceDB.find((x) => x?.type == benefit.type);
      if (benefitCount <= temp!.count) {
        for (let quantity of quantities) {
          quantity.count = quantity.count * improvement.level;
        }
        benefit.count = benefit.count * improvement.level;
        this.addResources(quantities); //Add freed up resources
        this.deductResources([benefit]); // Deduct the benefits given
        improvement.level = 0; //Remove improvement
        improvement.type = '';
        improvement.index = -1;
        return '';
      } else {
        console.error('Insufficient benefit resource to deduct');
        return 'Insufficient benefit resource to deduct';
      }
    } else {
      console.error('Improvement not found');
      return 'Improvement Removal unsuccessful';
    }
  }

  //Returns list of improvements
  getImprovements(): Improvement[] {
    return this.improvementsDB;
  }

  //Add given resources after Adding, upgrading, downgrading or removing Improvement
  addResources(inputResource: Resource[]): boolean {
    let valid = 'y';
    for (let item of inputResource) {
      if (item.count < 0) {
        console.error(`${item.type} is less than 0`);
        valid = 'n';
      } else {
        this.resourceDB.forEach((resource) => {
          if (resource.type == item.type) {
            resource.count += item.count;
          }
        });
      }
    }

    return valid == 'y';
  }

  //Deduct given resources after Adding, upgrading, downgrading or removing Improvement
  deductResources(inputResource: Resource[]): boolean {
    let valid = 'y';
    for (let item of inputResource) {
      this.resourceDB.forEach((data) => {
        if (data.type == item.type) {
          if (data.count < item.count) {
            console.error(`Insufficient ${data.type} to deduct`);
            valid = 'n';
          } else {
            data.count -= item.count;
          }
        }
      });
    }
    return valid == 'y';
  }

  //Return Resources available
  getResourceDB(): Resource[] {
    return this.resourceDB;
  }

  //Check if resource required for the improvement is available
  isResourceAvailable(improvementType: string, level: number = 0): boolean {
    let requiredMaterial: Resource[] | undefined;
    if (level == 0) {
      requiredMaterial = this.getRequiredMapDB(improvementType)?.required;
    } else {
      let record = this.getRequiredMapDB(improvementType)?.benefit;
      requiredMaterial = [{ type: record!.type, count: record!.count * level }];
    }

    if (requiredMaterial == undefined) {
      console.error('Improvement type not found');
      return false;
    }
    console.log('Input: Level: ' + level + ' type: ' + improvementType);
    console.log(requiredMaterial);
    for (let material of requiredMaterial) {
      let found = 'n';
      for (let resource of this.resourceDB) {
        if (
          material?.type == resource.type &&
          material?.count <= resource.count
        ) {
          found = 'y';
          break;
        }
      }
      if (found == 'n') {
        return false;
      }
    }
    return true;
  }

  //Return quatity for given improvement
  getImprovementType(): string[] {
    let improvementTypes: string[] = [];
    this.resourceRequirementMap.forEach((data) =>
      improvementTypes.push(data.type)
    );
    return improvementTypes;
  }

  //Return resource required data
  getRequiredMapDB(improvementType: string): RequirementMap | undefined {
    return this.resourceRequirementMap.find(
      (data) => data.type == improvementType
    );
  }

  //Initialize reference data
  initializeDataSet() {
    this.resourceRequirementMap = [
      {
        type: 'House',
        required: [
          { type: 'Lumber', count: 5 },
          { type: 'Grain', count: 5 },
          { type: 'Water', count: 5 },
          { type: 'Sheep', count: 1 },
        ],
        benefit: { type: 'Person', count: 5 },
      },
      {
        type: 'Field',
        required: [
          { type: 'Person', count: 1 },
          { type: 'Water', count: 2 },
        ],
        benefit: { type: 'Grain', count: 10 },
      },
      {
        type: 'Pasture',
        required: [
          { type: 'Person', count: 1 },
          { type: 'Grain', count: 2 },
          { type: 'Water', count: 2 },
        ],
        benefit: { type: 'Sheep', count: 5 },
      },
      {
        type: 'Lumber Mill',
        required: [{ type: 'Person', count: 1 }],
        benefit: { type: 'Lumber', count: 10 },
      },
      {
        type: 'Well',
        required: [
          { type: 'Person', count: 1 },
          { type: 'Lumber', count: 2 },
        ],
        benefit: { type: 'Water', count: 10 },
      },
    ];

    this.resourceDB = [
      { type: 'Person', count: 0 },
      { type: 'Grain', count: 5 },
      { type: 'Sheep', count: 1 },
      { type: 'Lumber', count: 5 },
      { type: 'Water', count: 5 },
    ];
  }
}
